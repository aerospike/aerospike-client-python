name: Valgrind

on:
  workflow_dispatch:
    inputs:
      test-file:
        description: 'new_test/<test-file>'
        required: false
        default: ""
      use-server-rc:
        type: boolean
        description: 'Use server release candidate?'
        required: true
        default: false
      massif:
        type: boolean
        description: 'Use massif for testing memory usage'
        required: false
        default: false

env:
  PYTHON_TAG: cp38
  WHEEL_OS: manylinux
  WHEEL_ARCH: x86_64

jobs:
  # TODO: handle case where we run valgrind on a "central" branch
  look-for-wheel-in-jfrog:
    if: ${{ github.ref_name != 'dev' && github.ref_name != 'stage' && github.ref_name != 'master' }}
    outputs:
      num_artifacts_found: ${{ steps.count_num_artifacts_found.outputs.num_artifacts }}
      python-tag: ${{ env.PYTHON_TAG }}
    env:
      JFROG_FILESPEC_NAME: jfrog-filespec.json
    runs-on: ubuntu-22.04
    steps:
    - uses: jfrog/setup-jfrog-cli@v4
      env:
        JF_URL: ${{ secrets.JFROG_PLATFORM_URL }}
        JF_ACCESS_TOKEN: ${{ secrets.JFROG_ACCESS_TOKEN }}

    - uses: actions/checkout@v4
      with:
        sparse-checkout-cone-mode: false
        sparse-checkout: .github/workflows/${{ env.JFROG_FILESPEC_NAME }}

    - name: Get shortened commit hash of this workflow run
      # versioningit commit sha is always 8 chars long it seems
      # We assume this prints out a sha that is unique and at most 8 chars
      run: echo SHORT_GITHUB_SHA=$(git rev-parse --short ${{ github.sha }}) >> $GITHUB_ENV

    - name: Set filespec variables
      # TODO: set using env var?
      run: echo SPEC_VARS_FLAG='--spec-vars="repo_name=${{ vars.JFROG_GENERIC_REPO_NAME }};branch=${{ github.ref_name }};commit_sha=${{ env.SHORT_GITHUB_SHA }};python_tag=${{ env.PYTHON_TAG }}"' >> $GITHUB_ENV

    - name: Look for wheel built with default settings in JFrog
      id: count_num_artifacts_found
      # We use AQL because we want to exclude builds if they have special labels, like unoptimized builds
      # We can't use a search pattern to exclude strings, as far as I know
      run: echo num_artifacts=$(jf rt search --count --spec=./${{ env.JFROG_FILESPEC_NAME }} ${{ env.SPEC_VARS_FLAG }}) >> $GITHUB_OUTPUT
      working-directory: .github/workflows

    - name: Cannot determine which artifact to use, fail out
      if: ${{ steps.count_num_artifacts_found.outputs.num_artifacts > 1 }}
      run: exit 1

    - name: Found the exact artifact in JFrog, downloading...
      if: ${{ steps.count_num_artifacts_found.outputs.num_artifacts == 1 }}
      run: jf rt download --flat --fail-no-op --spec=./${{ env.JFROG_FILESPEC_NAME }} ${{ env.SPEC_VARS_FLAG }}
      working-directory: .github/workflows

    - name: Pass to valgrind job
      if: ${{ steps.count_num_artifacts_found.outputs.num_artifacts == 1 }}
      uses: actions/upload-artifact@v4
      with:
        # Artifact name doesn't matter. Valgrind job downloads all artifacts to get the one wheel
        if-no-files-found: error
        path: './.github/workflows/*.whl'

  build-manylinux-wheel:
    needs: look-for-wheel-in-jfrog
    # If previous job was skipped, we are running on a central branch
    # Always build wheels from a central branch for now
    # Or if we are running on a feature branch and could not find any wheels in JFrog, build and upload it to JFrog
    if: ${{ !cancelled() && (needs.look-for-wheel-in-jfrog.result == 'skipped' || (needs.look-for-wheel-in-jfrog.result == 'success' && needs.look-for-wheel-in-jfrog.outputs.num_artifacts_found == 0)) }}
    uses: ./.github/workflows/build-wheels.yml
    with:
      python-tags: '["${{ needs.look-for-wheel-in-jfrog.outputs.python-tag }}"]'
      platform-tag: ${{ needs.look-for-wheel-in-jfrog.outputs.platform-tag }}
      sha-to-build-and-test: ${{ github.sha }}
    secrets: inherit

  upload-built-wheel-to-jfrog:
    needs: build-manylinux-wheel
    uses: ./.github/workflows/upload-to-jfrog.yml
    with:
      jfrog-repo-name: ${{ vars.JFROG_GENERIC_REPO_NAME }}
    secrets: inherit

  valgrind:
    env:
      MASSIF_REPORT_FILE_NAME: massif.out
    needs: build-manylinux-wheel
    if: ${{ !cancelled() && (needs.build-manylinux-wheel.result == 'success' || needs.build-manylinux-wheel.result == 'skipped') }}
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    - uses: actions/setup-python@v2
      with:
        python-version: '${{ env.PYTHON_VERSION }}'
        architecture: 'x64'

    - uses: actions/download-artifact@v4
      with:
        merge-multiple: true

    - name: Install client
      run: pip install ./*.whl

    - name: Install test dependencies
      run: pip install -r test/requirements.txt

    - name: Run EE server
      uses: ./.github/actions/run-ee-server
      with:
        use-server-rc: ${{ inputs.use-server-rc }}
        docker-hub-username: ${{ secrets.DOCKER_HUB_BOT_USERNAME }}
        docker-hub-password: ${{ secrets.DOCKER_HUB_BOT_PW }}

    - run: sudo apt update
    - run: sudo apt install valgrind -y

    - run: echo VALGRIND_ARGS="--tool=massif --massif-out-file=./${{ env.MASSIF_REPORT_FILE_NAME }}" >> $GITHUB_ENV
      if: ${{ inputs.massif }}

    - run: echo VALGRIND_ARGS="--leak-check=full" >> $GITHUB_ENV
      if: ${{ !inputs.massif }}

    - run: PYTHONMALLOC=malloc valgrind --error-exitcode=1 ${{ env.VALGRIND_ARGS }} python3 -m pytest -v new_tests/${{ github.event.inputs.test-file }}
      working-directory: test

    # TODO: upload report as artifact
    - run: ms_print ./${{ env.MASSIF_REPORT_FILE_NAME }}
      if: ${{ !cancelled() && inputs.massif }}
      working-directory: test

  # See reason for deleting artifacts in dev-workflow-p2.yml
  delete-artifacts:
    needs: [
      # These jobs must have downloaded the artifact from Github before we can delete it
      upload-built-wheel-to-jfrog,
      valgrind
    ]
    # Workflow run must clean up after itself even if cancelled
    if: ${{ always() }}
    uses: ./.github/workflows/delete-artifacts.yml
