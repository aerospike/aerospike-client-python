name: Dev to stage

on:
  # This workflow manipulates the stage and dev branches regardless of the branch this workflow is run from
  workflow_dispatch:

jobs:
  get-latest-dev-tag:
    outputs:
      latest-dev-version: ${{ steps.get-dev-version.outputs.latest-dev-version }}
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4
      with:
        # Get all tags
        fetch-depth: 0
        ref: ${{ vars.DEV_BRANCH_NAME }}

    - name: Get latest dev version
      run: echo latest-dev-version=$(git describe --tags --abbrev=0) >> $GITHUB_OUTPUT
      id: get-dev-version

  compare-dev-tag-and-stage:
    outputs:
      run_stage_tests: ${{ steps.run_stage_tests.outputs.run_stage_tests }}
    needs: get-latest-dev-tag
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4
      with:
        # Get all tags
        fetch-depth: 0

    - name: Get number of files that were changed between dev and stage (with some exceptions)
      run: echo NUM_FILES_CHANGED=$(git diff origin/${{ vars.STAGE_BRANCH_NAME }}..origin/${{ vars.DEV_BRANCH_NAME }} --name-only | grep --invert-match --count -e "^doc/" -e "^aerospike-stubs/" -e VERSION) >> $GITHUB_ENV
      # We want this step to fail if a command failed while using pipes
      shell: bash

    - name: If any files were changed besides the exceptions, run the stage tests
      run: echo run_stage_tests=${{ env.NUM_FILES_CHANGED != '0' }} >> $GITHUB_OUTPUT
      id: run_stage_tests

  run-stage-tests:
    needs: [
      get-latest-dev-tag,
      compare-dev-tag-and-stage
    ]
    if: ${{ needs.compare-dev-tag-and-stage.outputs.run_stage_tests == 'true' }}
    uses: ./.github/workflows/stage-tests.yml
    with:
      ref: ${{ needs.get-latest-dev-tag.outputs.latest-dev-version }}
    secrets: inherit

  # Stage tests have passed or skipped
  # so it is safe to update the stage branch with the changes in dev
  # and upload RC builds with the tested changes to JFrog
  # We store the subsequent jobs after the stage tests in a separate reusable workflow
  # because if stage tests were skipped, all subsequent jobs will be skipped by default too (both direct and indirect descendents)
  # This means we have to add a manual check for each subsequent job that checks if the stage tests were skipped in order to run them
  # It's easier to just add this manual check once to a reusable workflow that wraps around all those jobs
  bump-stage-and-upload-to-jfrog:
    needs: [
      run-stage-tests,
      get-latest-dev-tag
    ]
    if: ${{ !cancelled() && needs.get-latest-dev-tag.result == 'success' && (needs.run-stage-tests.result == 'success' || needs.run-stage-tests.result == 'skipped') }}
    uses: ./.github/workflows/bump-stage-and-upload-to-jfrog.yml
    with:
      tested-dev-tag: ${{ needs.get-latest-dev-tag.outputs.latest-dev-version }}
