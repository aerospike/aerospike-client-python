name: Stage tests

# Downloads artifacts either from Github or JFrog
# and runs category 1 (source distribution) and category 2 (binary distribution) tests
# The purpose is to test that our artifacts work on the Linux distros / OS versions that the client supports
# and QE doesn't have enough disk space for more Linux distros, so we have some tests here in Github Actions

on:
  workflow_call:
    inputs:
      use_jfrog_builds:
        description: If false, download artifacts from Github
        required: true
        type: boolean
        default: true
      jfrog-build-version-to-test:
        description: Used only when use_jfrog_builds is true.
        type: string
        required: false
      # These will be set if use_jfrog_builds is false (i.e when someone is building the artifacts from scratch and stage testing them in a calling workflow)
      # If use_jfrog_builds is true, only the defaults will be used
      registry-name:
        type: string
        required: false
        description: Registry name
        default: 'docker.io'
      image-name:
        type: string
        required: false
        description: Image name
        default: 'aerospike/aerospike-server-enterprise'
      server-tag:
        type: string
        required: false
        default: 'latest'
        description: 'Server docker image tag'
      test-macos-x86:
        required: false
        type: boolean
        default: false
        description: 'Test macOS x86 wheels (unstable)'

env:
  REGISTRY_USERNAME: ${{ inputs.registry-name == 'docker.io' && secrets.DOCKER_HUB_BOT_USERNAME || secrets.QE_DOCKER_REGISTRY_USERNAME }}
  REGISTRY_PASSWORD: ${{ inputs.registry-name == 'docker.io' && secrets.DOCKER_HUB_BOT_PW || secrets.QE_DOCKER_REGISTRY_PASSWORD }}

jobs:
  linux-distro-tests:
    strategy:
      matrix:
        test-case: [
          # Docker image + tag, test category, Docker image platform (cpu arch), Python version
          ["amazonlinux:2023", 1, "linux/amd64", "3.11"],
          ["amazonlinux:2023", 2, "linux/amd64", "3.11"],
          ["amazonlinux:2023", 2, "linux/arm64", "3.11"],
          ["ubuntu:22.04", 2, "linux/amd64", "3.10"],
          ["ubuntu:22.04", 2, "linux/arm64", "3.10"],
          ["ubuntu:24.04", 2, "linux/amd64", "3.12"],
          ["ubuntu:24.04", 2, "linux/arm64", "3.12"],
          # Bookworm is Debian 12
          ["python:3.10-bookworm", 2, "linux/amd64", "3.10"],
          ["python:3.10-bookworm", 2, "linux/arm64", "3.10"],
          ["python:3.11-bookworm", 2, "linux/amd64", "3.11"],
          ["python:3.11-bookworm", 2, "linux/arm64", "3.11"],
          ["python:3.12-bookworm", 2, "linux/amd64", "3.12"],
          ["python:3.12-bookworm", 2, "linux/arm64", "3.12"],
          ["python:3.13-bookworm", 2, "linux/amd64", "3.13"],
          ["python:3.13-bookworm", 2, "linux/arm64", "3.13"],
          ["python:3.14-rc-bookworm", 2, "linux/amd64", "3.14"],
          ["python:3.14-rc-bookworm", 2, "linux/arm64", "3.14"],
          # QE currently covers Debian 13 on all client-supported Python versions
          # We do not use ubi9/python-311 because we cannot install packages using dnf as root
          ["redhat/ubi9", 2, "linux/amd64", "3.11"],
          ["redhat/ubi9", 2, "linux/arm64", "3.11"],
          ["redhat/ubi9", 1, "linux/amd64", "3.11"],
        ]
      fail-fast: false
    env:
      LINUX_DISTRO_CONTAINER_NAME: linux-distro
      PIP_INSTALL_COMMAND: 'pip install'
    runs-on: ${{ matrix.test-case[2] == 'linux/amd64' && 'ubuntu-22.04' || 'ubuntu-22.04-arm' }}
    steps:
    # TODO: the checkout code is also duplicated in the macOS stage tests
    # But it's only a few lines of code so I didn't bother to create a composite action for it.
    - name: Harden the runner (Audit all outbound calls)
      uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2 # v2.13.3
      with:
        egress-policy: audit

    - name: Get tests and Github action scripts
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      with:
        ref: ${{ inputs.use_jfrog_builds && inputs.jfrog-build-version-to-test || github.sha }}
        sparse-checkout: |
          test
          .github

    # Map test case tuple entries to env vars to make code easier to read
    - run: echo "DISTRO_DOCKER_IMAGE_AND_TAG=${{ matrix.test-case[0] }}" >> $GITHUB_ENV
    - run: echo "TEST_CATEGORY=${{ matrix.test-case[1] }}" >> $GITHUB_ENV
    - run: echo "DISTRO_DOCKER_IMAGE_PLATFORM=${{ matrix.test-case[2] }}" >> $GITHUB_ENV
    - run: echo "PYTHON_VERSION=${{ matrix.test-case[3] }}" >> $GITHUB_ENV

    - uses: ./.github/actions/get-artifact-for-stage-tests
      with:
        get_from_jfrog: ${{ inputs.use_jfrog_builds }}
        # This input is only used if above input is true
        jfrog_build_version: ${{ inputs.jfrog-build-version-to-test }}
        dist_type_to_get: ${{ env.TEST_CATEGORY == '2' && 'wheel' || 'sdist' }}
        # wheel* inputs are used only if running category 2 tests
        wheel_python_version: ${{ env.PYTHON_VERSION }}
        wheel_os: manylinux
        wheel_cpu_arch: ${{ env.DISTRO_DOCKER_IMAGE_PLATFORM == 'linux/amd64' && 'x86_64' || 'aarch64' }}
        JFROG_PLATFORM_URL: ${{ secrets.JFROG_PLATFORM_URL }}
        JFROG_ACCESS_TOKEN: ${{ secrets.JFROG_ACCESS_TOKEN }}
        JFROG_REPO_NAME: ${{ vars.JFROG_REPO_NAME }}

    - uses: ./.github/actions/run-ee-server
      with:
        registry-name: ${{ inputs.registry-name }}
        registry-username: ${{ env.REGISTRY_USERNAME }}
        registry-password: ${{ env.REGISTRY_PASSWORD }}
        image-name: ${{ inputs.image-name }}
        server-tag: ${{ inputs.server-tag }}
        where-is-client-connecting-from: 'separate-docker-container'

    - name: Run distro container
      # Run distro container on host network to access the Aerospike server using localhost (without having to change config.conf)
      run: docker run --detach --network host --platform ${{ env.DISTRO_DOCKER_IMAGE_PLATFORM }} --name ${{ env.LINUX_DISTRO_CONTAINER_NAME }} ${{ env.DISTRO_DOCKER_IMAGE_AND_TAG }} tail -f /dev/null

    - name: Copy repo (and artifact) to container
      run: docker cp . ${{ env.LINUX_DISTRO_CONTAINER_NAME }}:/aerospike-client-python

    - name: 'DNF based distros: install python3'
      if: ${{ env.DISTRO_DOCKER_IMAGE_AND_TAG == 'amazonlinux:2023' || contains(env.DISTRO_DOCKER_IMAGE_AND_TAG, 'ubi') }}
      run: docker exec ${{ env.LINUX_DISTRO_CONTAINER_NAME }} dnf install -y python3.11

    - name: 'Ubuntu: Install python 3 that comes by default (step 1)'
      if: ${{ startsWith(env.DISTRO_DOCKER_IMAGE_AND_TAG, 'ubuntu') }}
      run: |
        docker exec ${{ env.LINUX_DISTRO_CONTAINER_NAME }} apt-get update
        docker exec ${{ env.LINUX_DISTRO_CONTAINER_NAME }} apt-get install python3 python3-pip -y

    - name: Make sure pip is installed
      # This is good to check in general, so we run for all distros
      # Ubuntu doesn't have this by default though, but it's fine since it has pip already
      if: ${{ !startsWith(env.DISTRO_DOCKER_IMAGE_AND_TAG, 'ubuntu') }}
      run: docker exec ${{ env.LINUX_DISTRO_CONTAINER_NAME }} python${{ env.PYTHON_VERSION }} -m ensurepip

    - name: 'Cat 1: Install build dependencies using dnf'
      # Here we assume all cat 1 tests are running on a dnf-based. distro
      if: ${{ env.TEST_CATEGORY == '1' }}
      run: |
        docker exec ${{ env.LINUX_DISTRO_CONTAINER_NAME }} dnf install -y libyaml-devel \
          openssl-devel \
          glibc-devel \
          autoconf \
          automake \
          libtool \
          zlib-devel \
          openssl-devel \
          python3.11-devel

    - if: ${{ env.DISTRO_DOCKER_IMAGE_AND_TAG == 'ubuntu:24.04' }}
      # Python 3.12+ fails to install packages to the system directory by default
      run: echo PIP_INSTALL_COMMAND="$PIP_INSTALL_COMMAND --break-system-packages" >> $GITHUB_ENV

    - name: 'Cat 1: Install pip build frontend'
      if: ${{ env.TEST_CATEGORY == '1' }}
      run: docker exec --workdir /aerospike-client-python/ ${{ env.LINUX_DISTRO_CONTAINER_NAME }} python${{ env.PYTHON_VERSION }} -m ${{ env.PIP_INSTALL_COMMAND }} -r requirements.txt

    - name: Install sdist or wheel distribution
      run: docker exec --workdir /aerospike-client-python/ ${{ env.LINUX_DISTRO_CONTAINER_NAME }} python${{ env.PYTHON_VERSION }} -m ${{ env.PIP_INSTALL_COMMAND }} ${{ env.ARTIFACT_FILE_NAME_PATTERN }}

    - name: Install pytest
      run: docker exec --workdir /aerospike-client-python/test ${{ env.LINUX_DISTRO_CONTAINER_NAME }} python${{ env.PYTHON_VERSION }} -m ${{ env.PIP_INSTALL_COMMAND }} pytest -c requirements.txt

    - name: Run tests
      run: docker exec --workdir /aerospike-client-python/test ${{ env.LINUX_DISTRO_CONTAINER_NAME }} python${{ env.PYTHON_VERSION }} -m pytest new_tests/

  macOS:
    if: ${{ inputs.test-macos-x86 }}
    strategy:
      matrix:
        runner-os-and-arch: [
          # These larger runners run on intel
          ["macos-15-large", "x86_64"],
          # arm64, since x86 not avaiable as Github hosted runner
          ["macos-26", "arm64"]
        ]
        python-version: [
          "3.10",
          "3.11",
          "3.12",
          "3.13",
          "3.14"
        ]
      fail-fast: false
    runs-on: ${{ matrix.runner-os-and-arch[0] }}
    steps:
    - name: Harden the runner (Audit all outbound calls)
      uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2 # v2.13.3
      with:
        egress-policy: audit

    - name: Get tests and Github action scripts
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      with:
        ref: ${{ inputs.use_jfrog_builds && inputs.jfrog-build-version-to-test || github.sha }}
        sparse-checkout: |
          test
          .github

    - uses: ./.github/actions/get-artifact-for-stage-tests
      with:
        # See comments in linux stage tests for how this works
        get_from_jfrog: ${{ inputs.use_jfrog_builds }}
        jfrog_build_version: ${{ inputs.jfrog-build-version-to-test }}
        dist_type_to_get: 'wheel'
        wheel_python_version: ${{ matrix.python-version }}
        wheel_os: macosx
        wheel_cpu_arch: ${{ matrix.runner-os-and-arch[1] }}
        JFROG_PLATFORM_URL: ${{ secrets.JFROG_PLATFORM_URL }}
        JFROG_ACCESS_TOKEN: ${{ secrets.JFROG_ACCESS_TOKEN }}
        JFROG_REPO_NAME: ${{ vars.JFROG_REPO_NAME }}

    - uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v6.1.0
      with:
        python-version: ${{ matrix.python-version }}

    - if: ${{ matrix.runner-os-and-arch[1] == 'x86_64' }}
      uses: ./.github/actions/setup-docker-on-macos

    - if: ${{ matrix.runner-os-and-arch[1] == 'x86_64' }}
      uses: ./.github/actions/run-ee-server
      with:
        registry-name: ${{ inputs.registry-name }}
        registry-username: ${{ env.REGISTRY_USERNAME }}
        registry-password: ${{ env.REGISTRY_PASSWORD }}
        image-name: ${{ inputs.image-name }}
        server-tag: ${{ inputs.server-tag }}
        where-is-client-connecting-from: 'docker-host'

    - name: Install wheel
      run: python3 -m pip install *.whl

    - name: Install test dependencies
      if: ${{ matrix.runner-os-and-arch[1] == 'x86_64' }}
      run: python3 -m pip install pytest -c requirements.txt
      working-directory: test

    - name: Run tests
      if: ${{ matrix.runner-os-and-arch[1] == 'x86_64' }}
      run: python3 -m pytest new_tests/
      working-directory: test

    - name: Run tests on macos 26
      if: ${{ matrix.runner-os-and-arch[1] == 'arm64' }}
      run: python3 -c "import aerospike"
      working-directory: test
