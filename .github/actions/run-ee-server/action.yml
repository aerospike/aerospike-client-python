name: 'Run EE Server in a Docker container'
description: 'Run EE server. Returns once server is ready. Only tested on Linux and macOS'
# NOTE: do not share this server container with others
# since it's using the default admin / admin credentials
inputs:
  # All inputs in composite actions are strings
  use-server-rc:
    required: true
    description: Deploy server release candidate?
    default: 'false'
  server-tag:
    required: true
    description: Specify Docker tag
    default: 'latest'
  # Github Composite Actions can't access secrets
  # so we need to pass them in as inputs
  docker-hub-username:
    description: Required for using release candidates
    required: false
  docker-hub-password:
    description: Required for using release candidates
    required: false

# Outputs a running server Docker container
# NOTE: side effects:
# If docker-hub-username and password are passed as inputs,
# a previous set of credentials used for docker will be overwritten
outputs:
  container-name:
    description: Server container name
    value: ${{ steps.get-container-name.outputs.container_name }}
  # TODO: how to get this dynamically?
  test-username:
    description: If security enabled, which username to use to log into server
    value: superuser
  test-password:
    description: If security enabled, which password to use to log into server
    value: superuser
  cluster-name:
    description: Used to connect to server via TLS
    value: ${{ steps.get-cluster-name.outputs.cluster_name }}
  tls-port:
    description: ''
    value: ${{ steps.get-tls-port.outputs.tls_port }}

runs:
  using: "composite"
  steps:
  - name: Log into Docker Hub to get server RC
    if: ${{ inputs.use-server-rc == 'true' }}
    run: docker login --username ${{ inputs.docker-hub-username }} --password ${{ inputs.docker-hub-password }}
    shell: bash

  - name: Get base image name
    id: get-base-image-name
    run: echo "base_image_name=${{ format('aerospike/aerospike-server-enterprise{0}:{1}', inputs.use-server-rc == 'true' && '-rc' || '', inputs.server-tag) }}" >> $GITHUB_OUTPUT
    shell: bash

  # macOS Github runners and Windows self-hosted runners don't have buildx installed by default
  - if: ${{ runner.os == 'Windows' || runner.os == 'macOS' }}
    uses: docker/setup-buildx-action@v3

  - run: echo CA_CERT_FILE_NAME="ca.cer" >> $GITHUB_ENV
    shell: bash

  - run: echo tls_port=4333 >> $GITHUB_OUTPUT
    id: get-tls-port
    shell: bash

  - name: Build Aerospike server Docker image for testing
    # We enable TLS standard authentication to verify that the OpenSSL library bundled with the wheel works
    # You can manually verify this by enabling debug logging in the client and checking that the server certificate was verified
    uses: docker/build-push-action@v6
    id: build-image
    with:
      # Don't want to use default Git context or else it will clone the whole Python client repo again
      context: .github/workflows/docker-build-context
      build-args: |
        SERVER_IMAGE=${{ steps.get-base-image-name.outputs.base_image_name }}
        TLS_PORT=${{ steps.get-tls-port.outputs.tls_port }}
      # setup-buildx-action configures Docker to use the docker-container build driver
      # This driver doesn't publish an image locally by default
      # so we have to manually enable it
      load: true

  - id: get-server-container-name
    run: echo "container_name=aerospike" >> $GITHUB_OUTPUT
    shell: bash

  - run: docker run -d --name ${{ steps.get-server-container-name.outputs.container_name }} -p 3000:3000 -p ${{ env.TLS_PORT }}:${{ env.TLS_PORT }} ${{ steps.build-image.outputs.imageid }}
    shell: bash

  - name: 'macOS: install timeout command'
    if: ${{ runner.os == 'macOS' }}
    run: brew install coreutils
    shell: bash

  - name: Wait for container to be healthy
    run: |
      timeout 30s bash -c 'until [[ "$(docker inspect -f {{.State.Health.Status}} ${{ steps.get-server-container-name.outputs.container_name }})" == "healthy" ]]; do sleep 0.1; done'
    shell: bash

  - name: Get cluster name
    id: get-cluster-name
    run: echo cluster_name=$(docker exec ${{ inputs.server-container-name }} asinfo -v "get-config:context=service" -l | grep -i cluster-name | cut -d = -f 2) >> $GITHUB_OUTPUT
    shell: bash

  # For debugging
  - run: docker logs ${{ steps.get-server-container-name.outputs.container_name }}
    shell: bash

  - name: Logout of Docker Hub
    run: docker logout
    shell: bash
