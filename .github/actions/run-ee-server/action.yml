name: 'Run EE Server in a Docker container'
description: 'Run EE server. Returns once server is ready. Only tested on Linux and macOS'
# NOTE: do not share this server container with others
# since it's using the default admin / admin credentials
inputs:
  # All inputs in composite actions are strings
  base-registry-name:
    description: Registry name
    required: false
    default: docker.io
  base-image-registry-username:
    description: Required for using release candidates
    required: false
  # Github Composite Actions can't access secrets
  # so we need to pass them in as inputs
  base-image-registry-password:
    description: Required for using release candidates
    required: false
  base-image-name:
    required: false
    description: aerospike/aerospike-server-enterprise
    default: 'aerospike/aerospike-server-enterprise'
  base-server-tag:
    required: true
    description: Specify Docker tag
    default: 'latest'
  where-is-client-connecting-from:
    required: false
    description: 'docker-host, separate-docker-container, "remote-connection" via DOCKER_HOST'
    default: 'docker-host'
  docker-run-extra-flags:
    required: false
    description: Used to disable server features
    default: ''

runs:
  using: "composite"
  steps:
  # Start up server

  - name: Log into registry to get non-public server RCs
    # We can still pull public images while logged in, so just do this all the time to make things simple
    uses: docker/login-action@v3
    with:
      registry: ${{ inputs.base-registry-name }}
      username: ${{ inputs.base-image-registry-username }}
      password: ${{ inputs.base-image-registry-password }}

  - run: echo BASE_IMAGE_FULL_NAME=${{ inputs.base-registry-name }}/${{ inputs.base-image-name }}:${{ inputs.base-server-tag }} >> $GITHUB_ENV
    shell: bash

  - run: echo CUSTOM_IMAGE_FULL_NAME=ghcr.io/${{ env.BASE_IMAGE_FULL_NAME }} >> $GITHUB_ENV
    shell: bash

  - name: Check if we already have a custom image built for this base image
    id: check-for-custom-image
    run: |
      docker pull $BASE_IMAGE_FULL_NAME
      # If this fails, build the custom image. We don't have a custom image to begin with for this base image tag
      docker pull $CUSTOM_IMAGE_FULL_NAME

      # TODO: make sure base image layers dont get squeezed together in the custom image
      get_last_layer_digest_for_this_arch () {
        # Assuming `docker image inspect` returns the image for this runner's specific CPU arch
        echo $(docker image inspect -f json $1 | jq '.[0].RootFS.Layers[-1]' -r | sed 's/.*sha256://')
      }
      BASE_IMAGE_DIGEST=$(get_last_layer_digest_for_this_arch $BASE_IMAGE_FULL_NAME)
      CUSTOM_IMAGE_LAYER_DIGESTS=$(docker image inspect -f json $1 | jq '.[0].RootFS.Layers -r)
      test "$(grep --count <(echo $CUSTOM_IMAGE_LAYER_DIGESTS))" == "1"
    shell: bash

  # QE images are not multi-platform and only support a single platform.
  - name: Allow building images from different platforms other than the native one
    if: ${{ steps.check-for-custom-image.outcome == 'failure' }}
    uses: docker/setup-qemu-action@v3

  # macOS Github runners and Windows self-hosted runners don't have buildx installed by default
  - if: ${{ steps.check-for-custom-image.outcome == 'failure' && (runner.os == 'Windows' || runner.os == 'macOS') }}
    uses: docker/setup-buildx-action@v3

  - run: echo CA_CERT_FILE_NAME="ca.cer" >> $GITHUB_ENV
    shell: bash

  - run: echo TLS_PORT="4333" >> $GITHUB_ENV
    shell: bash

  # - name: Check if a Docker image was already built for this base image
  #   id: check-if-image-already-built
  #   # We assume a non zero error code means the image does not exist (or at least it cannot be reached).
  #   run: |
  #     skopeo inspect --override-os linux $NEW_IMAGE_FULL_NAME
  #   shell: bash
  #   continue-on-error: true

  - name: Build Aerospike server Docker image for testing
    if: ${{ steps.check-for-custom-image.outcome == 'failure' }}
    # We enable TLS standard authentication to verify that the OpenSSL library bundled with the wheel works
    # You can manually verify this by enabling debug logging in the client and checking that the server certificate was verified
    uses: docker/build-push-action@v6
    with:
      # Don't want to use default Git context or else it will clone the whole Python client repo again
      context: .github/workflows/docker-build-context
      build-args: |
        SERVER_IMAGE=${{ env.BASE_IMAGE_FULL_NAME }}
        TLS_PORT=${{ env.TLS_PORT }}
      tags: ${{ env.CUSTOM_IMAGE_FULL_NAME }}
      # setup-buildx-action configures Docker to use the docker-container build driver
      # This driver doesn't publish an image locally by default
      # so we have to manually enable it
      load: true
      push: true

  - run: echo SERVER_CONTAINER_NAME="aerospike" >> $GITHUB_ENV
    shell: bash

  # Confirmed via logs that input string will not be quoted in bash
  - run: docker run -d ${{ inputs.docker-run-extra-flags }} --name ${{ env.SERVER_CONTAINER_NAME }} -p 3000:3000 -p ${{ env.TLS_PORT }}:${{ env.TLS_PORT }} ${{ env.NEW_IMAGE_FULL_NAME }}
    shell: bash

  - name: 'macOS: install timeout command'
    if: ${{ runner.os == 'macOS' }}
    run: brew install coreutils
    shell: bash

  - name: Wait for container to be healthy
    run: |
      timeout 30s bash -c 'until [[ "$(docker inspect -f {{.State.Health.Status}} ${{ env.SERVER_CONTAINER_NAME }})" == "healthy" ]]; do sleep 0.1; done'
    shell: bash

  # For debugging
  - run: docker logs ${{ env.SERVER_CONTAINER_NAME }}
    shell: bash

  # Configure tests

  - name: Install crudini to manipulate config.conf
    run: pipx install crudini --pip-args "-c ${{ github.workspace }}/.github/workflows/requirements.txt"
    working-directory: .github/workflows
    shell: bash

  - name: Create config.conf
    run: cp config.conf.template config.conf
    working-directory: test
    shell: bash

  - name: Disable community edition connection
    run: crudini --existing=param --set config.conf community-edition hosts ''
    working-directory: test
    shell: bash

  - run: echo SUPERUSER_NAME_AND_PASSWORD="superuser" >> $GITHUB_ENV
    shell: bash

  - name: Set credentials in config file
    run: |
      crudini --existing=param --set config.conf enterprise-edition user ${{ env.SUPERUSER_NAME_AND_PASSWORD }}
      crudini --existing=param --set config.conf enterprise-edition password ${{ env.SUPERUSER_NAME_AND_PASSWORD }}
      crudini --set config.conf tls enable true
      # Cannot use abs path because config.conf is copied into Docker container during cibuildwheel tests
      crudini --set config.conf tls cafile ../.github/workflows/docker-build-context/${{ env.CA_CERT_FILE_NAME }}
      crudini --set config.conf tls keyfile ../.github/workflows/docker-build-context/client.pem
      crudini --set config.conf tls certfile ../.github/workflows/docker-build-context/client.cer

    working-directory: test
    shell: bash

  - name: Set IP address to localhost
    if: ${{ inputs.where-is-client-connecting-from == 'docker-host' }}
    run: echo SERVER_IP=127.0.0.1 >> $GITHUB_ENV
    working-directory: test
    shell: bash

  - name: Set IP address to remote machine running the Docker daemon
    if: ${{ inputs.where-is-client-connecting-from == 'remote-connection' }}
    run: |
      SERVER_IP=${DOCKER_HOST/tcp:\/\//}
      echo SERVER_IP=${SERVER_IP/:2375/} >> $GITHUB_ENV
    working-directory: test
    shell: bash

  - name: Set IP address to Docker container for the server
    if: ${{ inputs.where-is-client-connecting-from == 'separate-docker-container' }}
    run: echo SERVER_IP=$(docker container inspect -f '{{ .NetworkSettings.IPAddress }}' ${{ env.SERVER_CONTAINER_NAME }}) >> $GITHUB_ENV
    shell: bash

  - name: Invalid input
    if: ${{ env.SERVER_IP == '' }}
    run: exit 1
    shell: bash

  - name: Get cluster name
    run: echo CLUSTER_NAME=$(docker exec ${{ env.SERVER_CONTAINER_NAME }} asinfo -v "get-config:context=service" -l | grep -i cluster-name | cut -d = -f 2) >> $GITHUB_ENV
    shell: bash

  - name: Set EE server's IP address
    run: crudini --existing=param --set config.conf enterprise-edition hosts "${{ env.SERVER_IP }}:${{ env.TLS_PORT }}|${{ env.CLUSTER_NAME }}"
    working-directory: test
    shell: bash
